<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: R | DataJujitsu]]></title>
  <link href="http://DASpringate.github.io/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://DASpringate.github.io/"/>
  <updated>2014-12-17T10:18:15+00:00</updated>
  <id>http://DASpringate.github.io/</id>
  <author>
    <name><![CDATA[David A Springate]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Book review: Machine Learning with R]]></title>
    <link href="http://DASpringate.github.io/blog/2014/01/31/book-review-machine-learning-with-r/"/>
    <updated>2014-01-31T14:17:41+00:00</updated>
    <id>http://DASpringate.github.io/blog/2014/01/31/book-review-machine-learning-with-r</id>
    <content type="html"><![CDATA[<p>Machine Learning with R by Brett Lantz</p>

<p>[Full disclosure &ndash; I was given a free review copy of the book from the publisher.  This review refers to the ebook version]</p>

<p>This is the most recent of a group of books that try to explore machine learning from a programming, rather than purely mathematical, perspective. The book is highly successful in this respect and deserves a place on the bookshelf of any data scientist, Kaggler or statistician.</p>

<p>The book takes a slightly different tack from previous ones in this field (See &lsquo;Programming Collective Intelligence&rsquo; and &lsquo;Machine learning for Hackers&rsquo;) in that it concentrates largely on the packages themselves and how to use them to solve real world ML problems, rather than focusing on coding up simple algorithms from scratch and running these on toy datasets.  Perhaps this way the book doesn&rsquo;t provide as much insight into how the algorithm design, but it does make the book much more practically useful, particularly since it spends a good chunk of each chapter explaining the algorithm in simple, plain English.</p>

<p>The book is well laid out and written.  Despite a slightly shaky start (do we really still think of ML in terms of Skynet, the Matrix and Hal?), the introduction is excellent and gives a pleasing summary of the philosophical and ethical issues surrounding machine learning and big data. Next, there is a thoughtful introduction to data management and exploratory data analysis that highlights important and often missed tips on things like getting data out of SQL databases.  It introduces some basic R functions and concepts (some I had managed to miss up until now) without feeling like a tacked on &lsquo;R for beginners&rsquo; chapter.</p>

<p>In the guts of the book, each chapter focuses on a group of related algorithms (KNN, Naive Bayes, Decision trees, Regression, Neural nets and SVMs, association rules, clustering) and has a good introduction to the algorithm in question, followed by sections on finding and cleaning data, implementing the algorithm on the data and evaluating and improving model performance. There are clear and easy to understand tables and descriptions of the important distinctions between the algorithms and the reasons for choosing one over another.  The datasets the author has chosen are large and interesting enough to well illustrate the points being made without being frustratingly unwieldy and many of them are &lsquo;classic&rsquo; machine learning datasets from places such as the UCI Machine Learning Data Repository.</p>

<p>Next, the book looks more deeply at evaluating and improving model performance and discusses important ensemble and meta-learning techniques like bagging, boosting and RandomForests.  This section will be of particular interest to people wanting to enter Kaggle or other data science competitions because they show how to milk as much performance as possible from the basic algorithms described earlier in the book.</p>

<p>The final section discusses getting the algorithms to run on big datasets and improving the performance of R itself using tricks like the data.table and ff packages and parallel processing.  This is the only section of the book that feels slightly rushed and many of these topics are discussed only briefly before linking to the relevant package documentation.  This is only small criticism though, since coding up these kinds of systems will depend strongly on the data you have and these are difficult subjects to cover whilst retaining generality.</p>

<p>Obviously, the book cannot cover everything.  It is decidedly light on graphs and has almost nothing on visualisation techniques and packages like ggplot2 which have become almost mandatory for doing data science today. Also, if you are new to R, you really want to get one of the excellent introductory books first and if you are new to ML, you probably want to spend a while learning some basic stats as well.  Finally, this book doesn&rsquo;t pretend to be a deep text about the mathematics of the algorithms it covers.  For that you will need to go for something like Bishop&rsquo;s classic &lsquo;Pattern Recognition and Machine Learning&rsquo; and be prepared to put in some serious effort!</p>

<p>In short, if you are looking for a practical guide to implementing ML algorithms on real data and if you are more comfortable thinking in R code than in mathematical equations, this is the book for you and is the best that I have seen on the subject so far.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Develop in RStudio, run in RScript]]></title>
    <link href="http://DASpringate.github.io/blog/2013/05/24/develop-in-rstudio/"/>
    <updated>2013-05-24T15:15:11+01:00</updated>
    <id>http://DASpringate.github.io/blog/2013/05/24/develop-in-rstudio</id>
    <content type="html"><![CDATA[<p>I have been using RStudio Server for a few months now and am finding it a great tool for R development.  The web interface is superb and behaves in almost exactly the same way as the desktop version.  However, I do have one gripe which has forced me to change my working practices slightly &ndash; It is really difficult to crash out of a frozen process.  Whereas in Console R, I could just hit Control-D to get out and back to Bash, in RStudio, while you can use the escape key to terminate an operation, if you have a big process going on everything just freezes and you can&rsquo;t do anything.  One way to deal with this is to kill the rstudio process in another terminal, but this kills the whole session, including the editor, and you will lose anything you haven&rsquo;t saved in your scripts.  This problem is exacerbated when I am trying to use run parallel processes using the <code>Multicore</code> package, because it takes an age to kill all of the extra forks first.</p>

<p>So, now I use RStudio for development and testing and run my final analysis scripts directly using Rscript.  I have this line of code at the start of my scripts&hellip;</p>

<p>```r
require(multicore)
cat(sprintf(&ldquo;Multicore functions running on maximum %d cores&rdquo;,</p>

<pre><code>        ifelse(length(commandArgs(trailingOnly=TRUE)), 
               cores &lt;- commandArgs(trailingOnly=TRUE)[1],
               cores &lt;- 1)))
</code></pre>

<p>```</p>

<p>```</p>

<h2>Multicore functions running on maximum 1 cores</h2>

<p>```</p>

<p>&hellip; so when I am testing in Rstudio, cores is set to 1, but when I run as an Rscript, I can specify how many cores I want to use.  I then just add <code>mc.cores = cores</code> to all of my <code>mclapply</code> calls like this:</p>

<p>```r</p>

<h1>Example processor hungry multicore operation</h1>

<p>mats &lt;&ndash; mclapply(1:500,</p>

<pre><code>             function(x) matrix(rnorm(x*x), 
                                ncol = x) %*% matrix(rnorm(x*x), 
                                                     ncol = x), 
             mc.cores = cores)
</code></pre>

<p>```</p>

<p>The advantage of this is that, when <code>mc.cores</code> are set to 1, <code>mclapply</code> just calls lapply which is easier to crash out of (try running the above code with cores set to more than 1 to see what I mean. It will hang for a lot longer) and produces more useful error messages:</p>

<p>```r</p>

<h1>Error handling with typos:</h1>

<h1>mcapply:</h1>

<p>mats &lt;&ndash; mclapply(1:500,</p>

<pre><code>             function(x) matrix(rnor(x*x), 
                                ncol = x) %*% matrix(rnorm(x*x), 
                                                     ncol = x), 
             mc.cores = 2)
</code></pre>

<p>```</p>

<p>```</p>

<h2>Warning: all scheduled cores encountered errors in user code</h2>

<p>```</p>

<p>```r</p>

<h1>Falls back to lapply with 1 core:</h1>

<p>mats &lt;&ndash; mclapply(1:500,</p>

<pre><code>             function(x) matrix(rnor(x*x), 
                                ncol = x) %*% matrix(rnorm(x*x), 
                                                     ncol = x), 
             mc.cores = 1)
</code></pre>

<p>```</p>

<p>```</p>

<h2>Error: could not find function &ldquo;rnor&rdquo;</h2>

<p>```</p>

<p>Running final analysis scripts has these advantages:</p>

<ul>
<li>You can much more easily crash out of them if there is a problem.</li>
<li>You can run several scripts in parallel without taking up console space</li>
<li>You can easily redirect the std error and std out from your program to a log file to keep an eye on its progress</li>
</ul>


<h2>Running multicore R scripts in the background with automatic logging</h2>

<p>If you have a bunch of R scripts that might each take hours to run, you don&rsquo;t want to clog up your RStudio console with them. This is a useful command to effectively run a big R analysis script in the background via Rscript.  It should work equally well for Linux and Mac:</p>

<p><code>
$ Rscript --vanilla R/myscript.R 12 &amp;&gt; logs/myscript.log &amp;
</code></p>

<p><code>Rscript</code> runs the .R file as a standalone script, without going into the R environment.  The <code>--vanilla</code> flag means that you run the script without calling in your .Rprofile (which is typically set up for interactive use) and without prompting you to save a workspace image. I always run the Rscript from the save level to that which is set as the project root for Rstudio to avoid any problems because of relative paths being set up wrongly. The number after the .R file to be run is the number of cores you want to run the parallel stuff on.  Other arguments you may want to pass to R would also go here. the <code>&amp;&gt;</code> operator redirects both the stdin and stderror to the file logs/myscript.log (I always set up a logs directory in my R projects for this purpose). The <code>&amp;</code> at the end runs the process in the background, so you get your bash prompt back while it is running.  Then if you want to check the progress of your script, just type:</p>

<p><code>
$ tail -f logs/myscript.log
</code></p>

<p>And you can watch the output of your script in real time. Hit Control-C to get back to your command prompt.  You can also use the <code>top</code> command to keep an eye on your processor usage.</p>

<p>If you want to kill your script, either find the PID number associated with your process in <code>top</code> and do <code>kill PIDNUMBER</code> or, if you are lazy/carefree, type <code>killall R</code> to kill any running R processes.  This will not affect your rstudio instance.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional programming in R]]></title>
    <link href="http://DASpringate.github.io/blog/2013/05/16/functional-programming-in-r/"/>
    <updated>2013-05-16T13:02:30+01:00</updated>
    <id>http://DASpringate.github.io/blog/2013/05/16/functional-programming-in-r</id>
    <content type="html"><![CDATA[<p><em>This post is based on a talk I gave at the <a href="http://www.meetup.com/Manchester-R/">Manchester R User Group</a> on functional programming in R on May 2nd 2013.  The original slides can be found <a href="http://www.slideshare.net/DASpringate/functional-programming-in-r">here</a></em></p>

<p>This post is about functional programming, why it is at the heart of the R language and how it can hopefully help you to write cleaner, faster and more bug-free R programs.
I will discuss what functional programming is at a very abstract level as a means of the representation of some simplified model of reality on a computer.  Then I&rsquo;ll talk about the elements that functional programming is comprised of and highlight the most important elements in programming in R.  I will then go through a quick example demo of a FP-style generic bootstrap algorithm to sample linear models and return bootstrap confidence intervals.  I&rsquo;ll compare this with a non-FP alternative version so you will hopefully clearly  see the advantages of using an FP style.  To wrap up, I&rsquo;ll make a few suggestions for places to go to if you want to learn more about functional programming in R.</p>

<h2>What is Functional programming?</h2>

<p>&hellip; Well, what is programming?  When you write a program you are building an  abstract representation of some tiny subset of reality on your computer, whether it is an experiment you have conducted or a model of some financial system or a collection of features of members of a population. There are obviously different ways to represent reality, and the different different methods of doing so programmatically can be thought of as the metaphysics of different styles of programming.</p>

<p>Consider for a moment building a representation of a river on a computer, a model of a river system for example.</p>

<p><img src="/images/posts/river.jpg" alt="alt River" /></p>

<p>In non-functional languages such as C++, Java and (to some extent) Python, the river is an object in itself, a <code>thing</code> that does <code>things</code> to other <code>things</code> and that may have various properties associated with it such as flow rate, depth and pollution levels.  These properties may change over time but there is always this constant, the river, which somehow persists over time.</p>

<p>In FP we look at things differently&hellip;</p>

<p><img src="/images/posts/heraclitus.jpg" alt="Hereclitus - We never step into the same river twice" /></p>

<p>The presocratic philosopher  Hereclitus said &ldquo;We never step into the same river twice&rdquo;, recognising that the thing we call a river is not really an object in itself, but something undergoing constant change through a variety of processes. In functional programming we are less concerned with the object of the river itself but rather the processes that it undergoes through time.  Our river at any point in time is just a collection of values (say, particles and their positions). These values then feed into a process to generate the series of values at the next time point.  So we have data flowing through processes of functions and that collection of data over time is what we call a river, which is really defined by the functions that the data flows through.  This is a very different way of looking at things to that of imperative, object oriented programming.</p>

<p>After this somewhat abstract and philosophical start, I&rsquo;ll talk about the more practical elements of functional programming (FP).  FP has been around for a very long time and originally  stems from Lisp, which was first implemented in the 1950&rsquo;s. It is making something of a comeback of late for a variety of reasons, but mostly because it is so good at dealing with concurrent, multicore problems potentially over many computers.  There are several elements that FP is generally considered to be comprised of.  Different languages highlight different elements, depending on how strictly functional they are.</p>

<h3>Functions are first class citizens of the language</h3>

<p>This means that functions can be treated just like any other data type &ndash; They can be passed around as arguments to other functions, returned by other functions and stored in lists.  This is the really big deal about functional programming and allows for higher-order functions (such as <code>lapply</code>) and closures, which I&rsquo;ll talk about later.  This is the most fundamental functional concept and I&rsquo;d argue that a language has to have this property in order to be called a functional language, even if it has some of the other elements listed below.  For example, Python has anonymous functions and supports declarative programming with list comprehensions and generators, but functions are fundamentally different from data-types such as lists so Python cannot really be described as a functional language in the same way as Scheme or R can be.</p>

<h3>Functional purity</h3>

<p>This is more of an element of good functional program design.  Pure functions take arguments, return values and otherwise have no side effects &ndash; no I/O or global variable changes.  This means that if you call a pure function twice with the same arguments, you know it will return the same value.  This means programs are easily tested because you can test different elements in isolation and once you know they work, you can treat them like a black box, knowing that they will not change some other part of your code somewhere else.  Some very strictly functional languages, like Haskell, insist on functional purity to the extent that in order to output data or read or write files you are forced to wrap your &lsquo;dirty&rsquo; functions in constructs called monads to preserve the purity of your code.  R does not insist on functional purity, but it is often good practice to split your code into pure and impure functions.  This means you can test your pure code easily and confine your I/O and random numbers etc to a small number of dirty functions.</p>

<h3>Vectorised functions</h3>

<p>Vectorised functions operate equally well on all elements of a vector as they do on a single number.  They are very important in R programming to the point that much of the criticism of R as a <code>really</code> slow language can be put down to failing to properly understand vectorisation.  This also includes the declarative style of programming, where you tell the language what you want, rather than how you want to get it.  This is common in languages like SQL and in Python generators.  I&rsquo;ll discuss this more later.</p>

<h3>Anonymous functions</h3>

<p>In FP, naming and applying a function are two separate operations, you don&rsquo;t need to give your functions names in order to call them. So, calling this function:</p>

<p><div>
  <pre><code class='R'>powfun &amp;lt;&amp;ndash; function(x, pow) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x^pow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
powfun(2, 10)</code></pre>
</div>
</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;[1] 1024&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>to the interpreter is exactly the same as applying variables to the anonymous function:</p>

<p><div>
  <pre><code class='R'>(function(x, pow) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x^pow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;})(2, 10)</code></pre>
</div>
</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;[1] 1024&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>This is particularly useful when you are building small, single use functions such as those used as arguments in higher order functions such as <code>lapply</code>.</p>

<h3>Immutable data structures</h3>

<p>Immutable data structures are associated with pure functions. The idea is that once an object such as a vector or list is created, it should not be changed.  You can&rsquo;t affect your data structures via side effects from other functions. Going back to our river example, doing so would be like going back in time and rearranging some of the molecules and starting again.  Having immutable objects means that you can reason more easily about what is going on in your program. Some languages, like Clojure, only have immutable data structures and it is impossible to change a list in place, you would have to have a list as an argument to a function which returns another list that you then assign back to the variable name for the original list.  R does not insist on immutability, but in general, data structures are only changed in this way and not through side effects.  It is often best to follow this, for the same reasons as it is best to have pure functions.</p>

<h3>Recursion</h3>

<p>Recursive functions are functions that call themselves.  Historically, these have been hugely important in FP, to the extent that some languages (for example Scheme) do not even have <code>for</code> loops and they define all of their looping constructs via recursion.  R does allow for recursive functions and they can sometimes be useful, particularly in traversal of tree-like data structures, but recursion in not very efficient in R (it is not <a href="http://en.wikipedia.org/wiki/Tail-call_optimization">tail-call optimised</a>) and I will not discuss it further here, though it may well be the subject of a future post.</p>

<h2>Functional Programming in R</h2>

<p>R has a reputation for being an ugly, hacked together and slow language. I think this is slightly unfair, but in this ever-so-slightly biassed account, I am going to blame the parents:</p>

<p><img src="/images/posts/R_genealogy.png" alt="R genealogy" /></p>

<p>R is the offspring of the languages <code>S</code> and <code>Scheme</code>.  S is a statistical language invented in the 1970&rsquo;s which is itself based on non-functional, imperative languages like C and Fortran.  It is useful in this domain and much of R&rsquo;s statistical abilities stem from this, but it is certainly less than pretty.  Scheme is a concise, elegant, functional language in the lisp family. The designers of R tried to build something with the statistical functionality of S and the elegance of Scheme.  Unfortunately, they left in much of the inelegant stuff from S as well and this mixed parentage means that it is now perfectly possible to write ugly, hacky, slow code in the style of S, just as it is also possible to write elegant, efficient functional code in the style of scheme.  The problem is that functional programming has been far less mainstream so people tend to learn to code in the way they know first, resulting in rafts of ugly, hacky R code.  Programming R in an elegant, functional way is not more difficult, but is immediately less intuitive to people who were brought up reading and writing imperative code.  I would always recommend people learning R to learn these functional concepts from the outset because this way you are working with how the language was designed, rather than against it.</p>

<p>To show just how functional a language is at its core, it is first important to recognise that everything in R is a function call, even if it looks like it isn&rsquo;t. So,</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1 + 2</code></pre>
</div>
</p></blockquote>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;[1] 3&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>&hellip; is exactly the same as&hellip;</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt;(1, 2)</code></pre>
</div>
</p></blockquote>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;[1] 3&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>The <code>+</code> operator is really just &ldquo;syntactic sugar&rdquo; for a <code>+</code> function with the arguments 1 and 2 applied to it. Similarly,</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1:10</code></pre>
</div>
</p></blockquote>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;[1]  1  2  3  4  5  6  7  8  9 10&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>&hellip; is the same as&hellip;</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;:&lt;/code&gt;(1, 10)</code></pre>
</div>
</p></blockquote>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;[1]  1  2  3  4  5  6  7  8  9 10&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>here again, to give the range of numbers between 1 and 10, <code>:</code> is really just a function in disguise.  If you were to break down more complex expressions in this way, the result would be code that looks very Scheme-like indeed.</p>

<p>I will now look in more depth at the functional concepts that are most important in R, Vectorised functions, higher order functions and closures.</p>

<h3>Vectorised functions</h3>

<p>Probably the best known FP concept in R is the vectorised function which &lsquo;automagically&rsquo; operates on a data structure like a vector in just the same way as on a single number.  Some of the most important of these are the <a href="http://rpubs.com/daspringate/subsetting">vector subsetting</a> operations. In these, you take a declarative approach to programming: you tell R what you want, not how to get it.  Because of this property of operating across vectors, proper use of vectorised functions will drastically reduce the number of loops you have to hand code into your scripts.  They are still performing loops under the hood, but these loops are implemented in C, so are many times faster than a standard for loop in R.</p>

<p>For example, when I was first using R for data management and analysis, I spent months writing code like this:</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;blockquote&gt;&lt;h1&gt;Get all even numbers up to 200000&lt;/h1&gt;

&lt;h1&gt;using S-style vector allocation:&lt;/h1&gt;

&lt;p&gt;x &amp;lt;&amp;ndash; c()
for(i in 1:200000){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(i %% 2 == 0){
    x &amp;lt;- c(x, i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}</code></pre>
</div>
</p></blockquote>

<p>This is about the worst possible way of achieving the given task (here, getting all even numbers up to 200000).  You are running a <code>for</code> loop, which is slow in itself, and testing if <code>i</code> is even on each iteration and then growing the <code>x</code> vector every time you find that it is.  The code is ugly, slow and verbose (On my machine it took around 10 seconds).</p>

<p>For me, writing vectorised code was a real revelation.  To achieve the same goal as the code above in a vectorised style:</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;blockquote&gt;&lt;h1&gt;FP style vectorised operation&lt;/h1&gt;

&lt;p&gt;a &amp;lt;&amp;ndash; 1:200000
x &amp;lt;&amp;ndash; a[a %% 2 == 0]</code></pre>
</div>
</p></blockquote>

<p>You assign a vector with all the values from 1 t0 200000, then you say &ldquo;I want all of these that are divisible by two&rdquo;.  This ran 3 orders of magnitude faster than the non-FP code, is half the length and clearer &ndash; you don&rsquo;t have to mentally run through the loop in order to work out what it does.  So you get the benefits of both concision (Number of bugs correlate well with lines of code) and clarity (The code becomes almost self-documenting).</p>

<p>This is a slightly unfair comparison and there are ways to speed up your loops, for example by pre-allocating a vector of the correct length before you run the loop.  However, even if you do this, the result will still be around 20 times slower and will be even more verbose.  It is good practice whenever you write a <code>for</code> loop in R to check if there is not a better way to do so using vectorised functions. The majority of R&rsquo;s built-in functions are vectorised and using these effectively is a prerequisite of using R effectively.</p>

<h3>Higher-order functions</h3>

<p>Because functions in R are first class citizens of the language, it is trivial to write and use functions that take other functions as arguments.  The most well used of these are the functions in the apply family (<code>lapply</code>, <code>sapply</code>, <code>apply</code> etc.).  These cause a lot of headaches for new-ish R users, who have just got to grips with for loops, but they are really no more difficult to use.  When you use one of these apply functions, you are just taking a collection of data (say a list or vector) and applying the input function to every element of the collection in turn, and collecting the results in another collection.</p>

<p><img src="/images/posts/apply_functions.png" alt="Apply functions" /></p>

<p>Because the mapping of each element to the function is independent of the elements around it, you can split the collections up and join them together at the end, which means that the functions can be better optimised than a <code>for</code> loop (especially in the case of <code>lapply</code>) and also easily run over multiple processor cores (see <code>multicore::mclapply</code>).</p>

<p>Conceptually, to use these functions you just need to think about what your input is, what the function you want to apply to each element is and what data structure you want as your output:</p>

<ul>
<li><code>lapply</code> : Any collection &ndash;> FUNCTION &ndash;> list</li>
<li><code>sapply</code> : Any collection &ndash;> FUNCTION &ndash;> matrix/vector</li>
<li><code>apply</code>  : Matrix/dataframe + margin &ndash;> FUNCTION &ndash;> matrix/vector</li>
<li><code>Reduce</code> : Any collection &ndash;> FUNCTION &ndash;> single element</li>
</ul>


<p>so if you want your output in a list, use <code>lapply</code>. If you want a vector or matrix, use <code>sapply</code>.  If you want to calculate summaries of the rows or columns of a dataframe, use <code>apply</code>. If you want to condense your dataset down into a single summary number, use <code>Reduce</code>.  There are several other functions in the same family, which all follow a similar pattern.</p>

<h3>Closures</h3>

<p>Closures are at the heart of all functional programming languages.  Essentially a closure is a function to which has been added data via its arguments.  The function &lsquo;closes over&rsquo; the data at the time the function was created and it is possible to access it at a later time.  Compare this to the idea of an object in languages like C++ and Java, which are data with functions attached to them.</p>

<p><img src="/images/posts/closure.png" alt="closures" /></p>

<p>You can use closures to build wrappers around functions with new default values and partially apply functions and even mimic Object-oriented style objects, but possibly most interestingly, you can build functions that return other functions.  This is great if you want to call a function many times on the same dataset but with different parameters, such as in maximum-likelihood optimisation problems when you are seeking to minimise some cost function and also for randomisation and bootstrapping algorithms.</p>

<p>To demonstrate the usefulness of this, I am now going to build a generic bootstrapping algorithm in a functional style that can be applied to any linear model.  It will demonstrate not only functions returning functions, but higher-order functions (in this case, <code>sapply</code>), anonymous functions (in the mapping function to <code>sapply</code>) and vectorised functions.  I will then compare this against a non-FP version of the algorithm and hopefully some of the advantages of writing in an FP style in R will become clear.  Here is the code. I am doing a bootstrap of a simple linear model on the classic <code>iris</code> dataset:</p>

<p><div>
  <pre><code class='R'>boot.lm &amp;lt;&amp;ndash; function(formula, data, &amp;hellip;){
  function(){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lm(formula=formula, 
   data=data[sample(nrow(data), replace=TRUE),], ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
}&lt;/p&gt;

&lt;p&gt;iris.boot &amp;lt;&amp;ndash; boot.lm(Sepal.Length ~ Petal.Length, iris)
bstrap &amp;lt;&amp;ndash; sapply(X=1:1000,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             FUN=function(x) iris.boot()$coef)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>That is the algorithm. The boot.lm function returns a closure.  You pass it a linear model formula and a dataframe and it returns a function with no arguments that itself returns a linear model object of a bootstrapped replicate (sample with replacement) of the supplied data.  So, the iris.boot function takes the formula of Sepal.Length~Petal.Length and the iris dataset and every time you call it it gives a new bootstrap replicate of that model on that data.  You then just need to run this 1000 times and collect the coefficients, which can be done with a one-liner sapply call.  We are using sapply because we want a matrix of coefficients with one line per replicate. The <code>FUN</code> argument to <code>sapply</code> is an anonymous function that returns the coefficients of the function.  You could have equally well have written something like</p>

<p><div>
  <pre><code class='R'>get.coefs &amp;lt;&amp;ndash; function(x){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iris.boot$coef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;bstrap &amp;lt;&amp;ndash; sapply(X=1:1000,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             FUN=get.coefs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>&hellip; but because the function is so short, it is no less clear to include it without a name.</p>

<p>Once the model has run, we can use the <code>apply</code> higher-order function to summarise the rows of <code>bstrap</code> by applying the <code>quantile</code> function to give the median and 95% confidence intervals:</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;p&gt;apply(bstrap, MARGIN=1, FUN=quantile,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  probs=c(0.025, 0.5, 0.975))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;(Intercept) Petal.Length&lt;/h2&gt;

&lt;h2&gt;2.5%        4.162       0.3701&lt;/h2&gt;

&lt;h2&gt;50%         4.304       0.4098&lt;/h2&gt;

&lt;h2&gt;97.5%       4.448       0.4472&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>This is an elegant way to solve a common analysis problem in R.  If you are running a large model and you want to speed things up (and you have a few cores free!), it is a simple task and a couple of lines of code to replace the call to <code>sapply</code> to one to <code>multicore::mclapply</code> and run the model on as many processor cores as you can.</p>

<p>In contrast, here is a roughly equivalent non-FP style bootstrapping algorithm:</p>

<p><div>
  <pre><code class='R'>boot_lm_nf &amp;lt;&amp;ndash; function(d, form, iters, output, &amp;hellip;){
  for(i in 1:iters){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- lm(formula=form, 
        data=d[sample(nrow(d),
               replace = TRUE),], ...)[[output]]
if(i == 1){
  bootstrap &amp;lt;- matrix(data=NA, nrow=iters, 
                ncol=length(x), 
                dimnames=list(NULL,names(x)))
  bootstrap[i,] &amp;lt;- x
} else bootstrap[i,] &amp;lt;- x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  }
  bootstrap
}</code></pre>
</div>
</p>

<p>This ugly beast is full of <code>for</code>s and <code>if</code>s and braces and brackets and double brackets.  It has a load of extra boilerplate code to define the variables and fill the matrices.  Plus, it is less generic than the FP version since you can only output the attributes of the model itself, whereas previously we could apply any function we like in place of the anonymous function in the <code>sapply</code> call.  It is more than twice as verbose and impossible to multicore without a complete rewrite.  On top of all that, getting the coefficients out in a non-FP way is a tedious task:</p>

<p><div>
  <pre><code class='R'>bstrap2 &amp;lt;&amp;ndash; boot_lm_nf(d=iris,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        form=Sepal.Length ~ Petal.Length, 
        iters=1000, output=&quot;coefficients&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CIs &amp;lt;&amp;ndash; c(0.025, 0.5, 0.975)
cbind( &amp;ldquo;(Intercept)&amp;rdquo;=quantile(bstrap2[,1],probs = CIs),&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &quot;Petal.Length&quot;=quantile(bstrap2[,2],probs = CIs))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='R'>&lt;/p&gt;

&lt;h2&gt;(Intercept) Petal.Length&lt;/h2&gt;

&lt;h2&gt;2.5%        4.169       0.3699&lt;/h2&gt;

&lt;h2&gt;50%         4.310       0.4081&lt;/h2&gt;

&lt;h2&gt;97.5%       4.448       0.4414&lt;/h2&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>The code duplication in the <code>cbind</code> is a pain, as is having to name the coefficients directly.  Both of these reduce the generalisability of the algorithm.</p>

<h2>Wrapping up</h2>

<p>I hope I have demonstrated that writing more functional R code is</p>

<ul>
<li>More concise (fewer lines of code)</li>
<li>Often faster (Particularly with effective vectorisation)</li>
<li>Clearer and less prone to bugs (because you are abstracting away a lot of the &lsquo;how to&rsquo; code)</li>
<li>More elegant</li>
</ul>


<p>R is a strongly functional language to its core and if you work with this in your code, your R hacking will be more intuitive, productive and enjoyable.</p>

<h2>Further Reading</h2>

<p>Here are some good and accessible resources available if you want to learn more about functional programming in general and FP in R in particular:</p>

<ul>
<li><a href="mitpress.mit.edu/sicp">Structure and interpretation of computer programs</a> by Abelson and Sussman is the bible of FP and is written by the creators of Scheme.  This book has been used as the core of the MIT Computer Science course since the early 1990s and is still not dated.</li>
<li><a href="github.com/hadley/devtools/wiki">Hadley Wickham&rsquo;s in progress ebook</a> on Github is a fantastic resource on FP in R amongst a host of other advanced R topics.</li>
<li><a href="www.burns-stat.com/pages/Tutor/R_inferno.pdf">The R Inferno</a> by Patrick Burns is a classic free online book on R and has a great chapter on vectorisation and when it is best to apply it.</li>
<li>If you are intersted in the metaphysical stuff at the start of this post, Rich Hickey, the inventor of the Clojure language give <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">this</a> great talk on the importance of FP and the failings of the traditional OOP model.  The talk was also summarised nicely in <a href="http://www.flyingmachinestudios.com/programming/the-unofficial-guide-to-rich-hickeys-brain/">this</a> blog post.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two R Tutorials for beginners]]></title>
    <link href="http://DASpringate.github.io/blog/2013/04/16/two-r-tutorials-for-beginners/"/>
    <updated>2013-04-16T12:57:00+01:00</updated>
    <id>http://DASpringate.github.io/blog/2013/04/16/two-r-tutorials-for-beginners</id>
    <content type="html"><![CDATA[<p>I am currently in the process of rescuing some of the pages from my now defunct datajujitsu.co.uk blogger blog and moving here.  I also today gave a tutorial to the University of Manchester on data cleaning and subsetting, so I am killing two birds with one stone by linking to the <a href="http://rpubs.com/">Rpubs</a> pages for both this and a short tutorial I gave last year on vectorisation.</p>

<p>The tutorials are:</p>

<ol>
<li><a href="http://rpubs.com/daspringate/subsetting">Subsetting in R: Spring cleaning your data</a></li>
<li><a href="http://rpubs.com/daspringate/vectorisation">Speeding up your R code &ndash; vectorisation tricks for beginners</a></li>
</ol>


<p>The R markdown source file for both of these are available on <a href="https://github.com/DASpringate/tutorials">my github page</a>. Rpubs is a great site from the people behind RStudio that allows you to upload R markdown scripts compiled using Knitr in no time at all.</p>

<p>Using R Markdown, Knitr, RStudio and Rpubs to produce and publish tutorials has proved a complete joy.  It is simple, quick and painless to get pages online with embedded R code and output.</p>

<p>I have also produced a slide presentation for an internal seminar series in my department using R Markdown, Knitr, Pandoc and Beamer. I was really pleased with the results (Which are also on my <a href="https://github.com/DASpringate/tutorials/tree/master/Primary_Care_Databases/March_2013">github page</a>) and how easily I was able to achieve them, particularly with  the huge reduction of Latex boilerplate I was forced to write.  I will be doing all of my presentations with this method in future and will blog about the workflow for doing so in due course.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scraping organism metadata for Treebase repositories from GOLD using Python and R]]></title>
    <link href="http://DASpringate.github.io/blog/2013/04/16/scraping-organism-metadata-for-treebase-repositories-from-gold-using-python-and-r/"/>
    <updated>2013-04-16T12:37:59+01:00</updated>
    <id>http://DASpringate.github.io/blog/2013/04/16/scraping-organism-metadata-for-treebase-repositories-from-gold-using-python-and-r</id>
    <content type="html"><![CDATA[<p>I recently wanted to get hold of habitat/phenotype/sequencing metadata for the individual organisms of  an archived <a href="http://treebase.org/treebase-web/home.html">Treebase</a> project.</p>

<p>The <a href="http://www.genomesonline.org/">GOLD</a> database holds  more than 18000 full genomes.  For many of these it provides pretty good metadata (<a href="http://genomesonline.org/cgi-bin/GOLD/bin/GOLDCards.cgi?goldstamp=Gc00536">GOLDcards</a>) which are indirectly linked  to Treebase via <a href="http://www.ncbi.nlm.nih.gov/taxonomy">NCBI</a> taxa <a href="http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?mode=Info&amp;amp;id=122368">IDs</a>.</p>

<p>Unfortunately GOLD does not seem to have any kind of API for systematic downloads, so I hacked together a very <a href="https://gist.github.com/2929217">quick-and-dirty scraper</a> in Python that reads in taxa from a Treebase repo, follows the links to each species NCBI page and downloads the linked GOLDcard, if it exists.</p>

<p>Here is the code. You will need the external BeautifulSoup and lxml libraries for this to work &ndash; both are fantastic. (The Treebase repo here is from Wu et al. 2009**, just change the url string for a different repo):</p>

<p>Once you have downloaded all of the available files, It would be great to have your metadata in a nice flatfile with one line per taxa, right?  I did this with a little <a href="https://gist.github.com/2929366">R script</a> using the rather wonderful readHTMLtable() function in the XML (install.packages(&lsquo;XML&rsquo;)) package.</p>

<p>The output is a semicolon separated file with taxa in the rows and the different categories of metadata in columns. The metadata is often fairly incomplete, and  there are plenty of omissions, but hopefully it will become more useful as more deposits are made to GOLD.</p>

<p>** Wu D., Hugenholtz P., Mavromatis K., Pukall R., Dalin E., Ivanova N.N., Kunin V., Goodwin L., Wu M., Tindall B.J., Hooper S.D., Pati A., Lykidis A., Spring S., Anderson I.J., D'haeseleer P., Zemla A., Singer M., Lapidus A., Nolan M., Copeland A., Chen F., Cheng J., Lucas S., Kerfeld C., Lang E., Gronow S., Chain P., Bruce D., Rubin E.M., Kyrpides N.C., Klenk H., &amp; Eisen J.A. 2009. A phylogeny-driven genomic encyclopaedia of Bacteria and Archaea. Nature, 462(7276): 1056-1060.</p>
]]></content>
  </entry>
  
</feed>
